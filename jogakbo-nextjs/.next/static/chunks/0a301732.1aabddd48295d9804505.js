(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[6],{T1Xd:function(e,t,n){"use strict";n.d(t,"a",(function(){return Ys})),n.d(t,"b",(function(){return Xs})),n.d(t,"c",(function(){return Qs})),n.d(t,"d",(function(){return ei}));var o=n("q1tI"),r=n.n(o),a=n("i8i4"),s=n.n(a);var i=function(e){const t=new Error(e);if(void 0===t.stack)try{throw t}catch(n){}return t};var u=function(e){return!!e&&"function"===typeof e.then};var c=function(e,t){if(null!=e)return e;throw i(null!==t&&void 0!==t?t:"Got unexpected null or undefined")};function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}class d{getValue(){throw i("BaseLoadable")}toPromise(){throw i("BaseLoadable")}valueMaybe(){throw i("BaseLoadable")}valueOrThrow(){throw i(`Loadable expected value, but in "${this.state}" state`)}promiseMaybe(){throw i("BaseLoadable")}promiseOrThrow(){throw i(`Loadable expected promise, but in "${this.state}" state`)}errorMaybe(){throw i("BaseLoadable")}errorOrThrow(){throw i(`Loadable expected error, but in "${this.state}" state`)}is(e){return e.state===this.state&&e.contents===this.contents}map(e){throw i("BaseLoadable")}}class f extends d{constructor(e){super(),l(this,"state","hasValue"),l(this,"contents",void 0),this.contents=e}getValue(){return this.contents}toPromise(){return Promise.resolve(this.contents)}valueMaybe(){return this.contents}valueOrThrow(){return this.contents}promiseMaybe(){}errorMaybe(){}map(e){try{const t=e(this.contents);return u(t)?m(t):g(t)?t:v(t)}catch(t){return u(t)?m(t.next((()=>this.map(e)))):y(t)}}}class h extends d{constructor(e){super(),l(this,"state","hasError"),l(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return Promise.reject(this.contents)}valueMaybe(){}promiseMaybe(){}errorMaybe(){return this.contents}errorOrThrow(){return this.contents}map(e){return this}}class p extends d{constructor(e){super(),l(this,"state","loading"),l(this,"contents",void 0),this.contents=e}getValue(){throw this.contents}toPromise(){return this.contents}valueMaybe(){}promiseMaybe(){return this.contents}promiseOrThrow(){return this.contents}errorMaybe(){}map(e){return m(this.contents.then((t=>{const n=e(t);if(g(n)){const e=n;switch(e.state){case"hasValue":return e.contents;case"hasError":throw e.contents;case"loading":return e.contents}}return n})).catch((t=>{if(u(t))return t.then((()=>this.map(e).contents));throw t})))}}function v(e){return Object.freeze(new f(e))}function y(e){return Object.freeze(new h(e))}function m(e){return Object.freeze(new p(e))}function _(e){const t=function(e){return e.every((e=>"hasValue"===e.state))?v(e.map((e=>e.contents))):e.some((e=>"hasError"===e.state))?y(c(e.find((e=>"hasError"===e.state)),"Invalid loadable passed to loadableAll").contents):m(Promise.all(e.map((e=>e.contents))))}((Array.isArray(e)?e:Object.getOwnPropertyNames(e).map((t=>e[t]))).map((e=>g(e)?e:u(e)?m(e):v(e))));return Array.isArray(e)?t:t.map((t=>Object.getOwnPropertyNames(e).reduce(((e,n,o)=>({...e,[n]:t[o]})),{})))}function g(e){return e instanceof d}const S={of:e=>u(e)?m(e):g(e)?e:v(e),error:e=>y(e),all:_,isLoadable:g};var b={loadableWithValue:v,loadableWithError:y,loadableWithPromise:m,loadableLoading:function(){return Object.freeze(new p(new Promise((()=>{}))))},loadableAll:_,isLoadable:g,RecoilLoadable:S},T=b.loadableWithValue,R=b.loadableWithError,w=b.loadableWithPromise,A=b.loadableLoading,E=b.loadableAll,N=b.isLoadable,k=b.RecoilLoadable,V=Object.freeze({__proto__:null,loadableWithValue:T,loadableWithError:R,loadableWithPromise:w,loadableLoading:A,loadableAll:E,isLoadable:N,RecoilLoadable:k});class L{constructor(e){l(this,"key",void 0),this.key=e}}class M extends L{}class C extends L{}var U={AbstractRecoilValue:L,RecoilState:M,RecoilValueReadOnly:C,isRecoilValue:function(e){return e instanceof M||e instanceof C}},B=U.AbstractRecoilValue,D=U.RecoilState,I=U.RecoilValueReadOnly,O=U.isRecoilValue,x=Object.freeze({__proto__:null,AbstractRecoilValue:B,RecoilState:D,RecoilValueReadOnly:I,isRecoilValue:O});var P=function(e,...t){0};const z=(new Map).set("recoil_hamt_2020",!0).set("recoil_sync_external_store",!0).set("recoil_suppress_rerender_in_callback",!0).set("recoil_memory_managament_2020",!0);function F(e){var t;return null!==(t=z.get(e))&&void 0!==t&&t}F.setPass=e=>{z.set(e,!0)},F.setFail=e=>{z.set(e,!1)},F.clear=()=>{z.clear()};var W=F;var $=function(e,t){return function*(){let n=0;for(const o of e)yield t(o,n++)}()};var j=function(e,t,{error:n}={}){return null};class G{}const q=new G;class H extends Error{constructor(e){super(`Tried to set the value of Recoil selector ${e} using an updater function, but it is an async selector in a pending or error state; this is not supported.`)}}const K=new Map,Z=new Map;class J extends Error{}const Y=new Map;function X(e){return Y.get(e)}var Q={nodes:K,recoilValues:Z,registerNode:function(e){if(K.has(e.key)){const t=`Duplicate atom key "${e.key}". This is a FATAL ERROR in\n      production. But it is safe to ignore this warning if it occurred because of\n      hot module replacement.`;console.warn(t)}K.set(e.key,e);const t=null==e.set?new x.RecoilValueReadOnly(e.key):new x.RecoilState(e.key);return Z.set(e.key,t),t},getNode:function(e){const t=K.get(e);if(null==t)throw new J(`Missing definition for RecoilValue: "${e}""`);return t},getNodeMaybe:function(e){return K.get(e)},deleteNodeConfigIfPossible:function(e){var t;if(!W("recoil_memory_managament_2020"))return;const n=K.get(e);var o;null!==n&&void 0!==n&&null!==(t=n.shouldDeleteConfigOnRelease)&&void 0!==t&&t.call(n)&&(K.delete(e),null===(o=X(e))||void 0===o||o(),Y.delete(e))},setConfigDeletionHandler:function(e,t){W("recoil_memory_managament_2020")&&(void 0===t?Y.delete(e):Y.set(e,t))},getConfigDeletionHandler:X,recoilValuesForKeys:function(e){return $(e,(e=>c(Z.get(e))))},NodeMissingError:J,DefaultValue:G,DEFAULT_VALUE:q,RecoilValueNotReady:H};var ee={enqueueExecution:function(e,t){t()}};var te=function(e,t){return e(t={exports:{}},t.exports),t.exports}((function(e){var t="function"===typeof Symbol&&"symbol"===typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"===typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n={},o=Math.pow(2,5),r=o-1,a=o/2,s=o/4,i={},u=function(e){return function(){return e}},c=n.hash=function(e){var n="undefined"===typeof e?"undefined":t(e);if("number"===n)return e;"string"!==n&&(e+="");for(var o=0,r=0,a=e.length;r<a;++r){o=(o<<5)-o+e.charCodeAt(r)|0}return o},l=function(e,t){return t>>>e&r},d=function(e){return 1<<e},f=function(e,t){return n=e&t-1,n=(n=(858993459&(n-=n>>1&1431655765))+(n>>2&858993459))+(n>>4)&252645135,127&(n+=n>>8)+(n>>16);var n},h=function(e,t,n,o){var r=o;if(!e){var a=o.length;r=new Array(a);for(var s=0;s<a;++s)r[s]=o[s]}return r[t]=n,r},p=function(e,t,n){var o=n.length-1,r=0,a=0,s=n;if(e)r=a=t;else for(s=new Array(o);r<t;)s[a++]=n[r++];for(++r;r<=o;)s[a++]=n[r++];return e&&(s.length=o),s},v={__hamt_isEmpty:!0},y=function(e){return e===v||e&&e.__hamt_isEmpty},m=function(e,t,n,o){return{type:1,edit:e,hash:t,key:n,value:o,_modify:R}},_=function(e,t,n){return{type:2,edit:e,hash:t,children:n,_modify:w}},g=function(e,t,n){return{type:3,edit:e,mask:t,children:n,_modify:A}},S=function(e,t,n){return{type:4,edit:e,size:t,children:n,_modify:E}},b=function e(t,n,o,r,a,s){if(o===a)return _(t,o,[s,r]);var i=l(n,o),u=l(n,a);return g(t,d(i)|d(u),i===u?[e(t,n+5,o,r,a,s)]:i<u?[r,s]:[s,r])},T=function(e,t){return e===t.edit},R=function(e,t,n,o,r,a,s){if(t(a,this.key)){var u=o(this.value);return u===this.value?this:u===i?(--s.value,v):T(e,this)?(this.value=u,this):m(e,r,a,u)}var c=o();return c===i?this:(++s.value,b(e,n,this.hash,this,r,m(e,r,a,c)))},w=function(e,t,n,o,r,a,s){if(r===this.hash){var u=function(e,t,n,o,r,a,s,u){for(var c=r.length,l=0;l<c;++l){var d=r[l];if(n(s,d.key)){var f=d.value,v=a(f);return v===f?r:v===i?(--u.value,p(e,l,r)):h(e,l,m(t,o,s,v),r)}}var y=a();return y===i?r:(++u.value,h(e,c,m(t,o,s,y),r))}(T(e,this),e,t,this.hash,this.children,o,a,s);return u===this.children?this:u.length>1?_(e,this.hash,u):u[0]}var c=o();return c===i?this:(++s.value,b(e,n,this.hash,this,r,m(e,r,a,c)))},A=function(e,t,n,o,r,s,i){var u=this.mask,c=this.children,m=l(n,r),_=d(m),b=f(u,_),R=u&_,w=R?c[b]:v,A=w._modify(e,t,n+5,o,r,s,i);if(w===A)return this;var E,N=T(e,this),k=u,V=void 0;if(R&&y(A)){if(!(k&=~_))return v;if(c.length<=2&&((E=c[1^b])===v||1===E.type||2===E.type))return c[1^b];V=p(N,b,c)}else if(R||y(A))V=h(N,b,A,c);else{if(c.length>=a)return function(e,t,n,o,r){for(var a=[],s=o,i=0,u=0;s;++u)1&s&&(a[u]=r[i++]),s>>>=1;return a[t]=n,S(e,i+1,a)}(e,m,A,u,c);k|=_,V=function(e,t,n,o){var r=o.length;if(e){for(var a=r;a>=t;)o[a--]=o[a];return o[t]=n,o}for(var s=0,i=0,u=new Array(r+1);s<t;)u[i++]=o[s++];for(u[t]=n;s<r;)u[++i]=o[s++];return u}(N,b,A,c)}return N?(this.mask=k,this.children=V,this):g(e,k,V)},E=function(e,t,n,o,r,a,i){var u=this.size,c=this.children,d=l(n,r),f=c[d],p=(f||v)._modify(e,t,n+5,o,r,a,i);if(f===p)return this;var m=T(e,this),_=void 0;if(y(f)&&!y(p))++u,_=h(m,d,p,c);else if(!y(f)&&y(p)){if(--u<=s)return function(e,t,n,o){for(var r=new Array(t-1),a=0,s=0,i=0,u=o.length;i<u;++i)if(i!==n){var c=o[i];c&&!y(c)&&(r[a++]=c,s|=1<<i)}return g(e,s,r)}(e,u,d,c);_=h(m,d,v,c)}else _=h(m,d,p,c);return m?(this.size=u,this.children=_,this):S(e,u,_)};function N(e,t,n,o,r){this._editable=e,this._edit=t,this._config=n,this._root=o,this._size=r}v._modify=function(e,t,n,o,r,a,s){var u=o();return u===i?v:(++s.value,m(e,r,a,u))},N.prototype.setTree=function(e,t){return this._editable?(this._root=e,this._size=t,this):e===this._root?this:new N(this._editable,this._edit,this._config,e,t)};var k=n.tryGetHash=function(e,t,n,o){for(var r=o._root,a=0,s=o._config.keyEq;;)switch(r.type){case 1:return s(n,r.key)?r.value:e;case 2:if(t===r.hash)for(var i=r.children,u=0,c=i.length;u<c;++u){var h=i[u];if(s(n,h.key))return h.value}return e;case 3:var p=l(a,t),v=d(p);if(r.mask&v){r=r.children[f(r.mask,v)],a+=5;break}return e;case 4:if(r=r.children[l(a,t)]){a+=5;break}return e;default:return e}};N.prototype.tryGetHash=function(e,t,n){return k(e,t,n,this)};var V=n.tryGet=function(e,t,n){return k(e,n._config.hash(t),t,n)};N.prototype.tryGet=function(e,t){return V(e,t,this)};var L=n.getHash=function(e,t,n){return k(void 0,e,t,n)};N.prototype.getHash=function(e,t){return L(e,t,this)};n.get=function(e,t){return k(void 0,t._config.hash(e),e,t)};N.prototype.get=function(e,t){return V(t,e,this)};var M=n.has=function(e,t,n){return k(i,e,t,n)!==i};N.prototype.hasHash=function(e,t){return M(e,t,this)};var C=n.has=function(e,t){return M(t._config.hash(e),e,t)};N.prototype.has=function(e){return C(e,this)};var U=function(e,t){return e===t};n.make=function(e){return new N(0,0,{keyEq:e&&e.keyEq||U,hash:e&&e.hash||c},v,0)},n.empty=n.make();var B=n.isEmpty=function(e){return e&&!!y(e._root)};N.prototype.isEmpty=function(){return B(this)};var D=n.modifyHash=function(e,t,n,o){var r={value:o._size},a=o._root._modify(o._editable?o._edit:NaN,o._config.keyEq,0,e,t,n,r);return o.setTree(a,r.value)};N.prototype.modifyHash=function(e,t,n){return D(n,e,t,this)};var I=n.modify=function(e,t,n){return D(e,n._config.hash(t),t,n)};N.prototype.modify=function(e,t){return I(t,e,this)};var O=n.setHash=function(e,t,n,o){return D(u(n),e,t,o)};N.prototype.setHash=function(e,t,n){return O(e,t,n,this)};var x=n.set=function(e,t,n){return O(n._config.hash(e),e,t,n)};N.prototype.set=function(e,t){return x(e,t,this)};var P=u(i),z=n.removeHash=function(e,t,n){return D(P,e,t,n)};N.prototype.removeHash=N.prototype.deleteHash=function(e,t){return z(e,t,this)};var F=n.remove=function(e,t){return z(t._config.hash(e),e,t)};N.prototype.remove=N.prototype.delete=function(e){return F(e,this)};var W=n.beginMutation=function(e){return new N(e._editable+1,e._edit+1,e._config,e._root,e._size)};N.prototype.beginMutation=function(){return W(this)};var $=n.endMutation=function(e){return e._editable=e._editable&&e._editable-1,e};N.prototype.endMutation=function(){return $(this)};var j=n.mutate=function(e,t){var n=W(t);return e(n),$(n)};N.prototype.mutate=function(e){return j(e,this)};var G=function(e){return e&&q(e[0],e[1],e[2],e[3],e[4])},q=function(e,t,n,o,r){for(;n<e;){var a=t[n++];if(a&&!y(a))return H(a,o,[e,t,n,o,r])}return G(r)},H=function(e,t,n){switch(e.type){case 1:return{value:t(e),rest:n};case 2:case 4:case 3:var o=e.children;return q(o.length,o,0,t,n);default:return G(n)}},K={done:!0};function Z(e){this.v=e}Z.prototype.next=function(){if(!this.v)return K;var e=this.v;return this.v=G(e.rest),e},Z.prototype[Symbol.iterator]=function(){return this};var J=function(e,t){return new Z(H(e._root,t))},Y=function(e){return[e.key,e.value]},X=n.entries=function(e){return J(e,Y)};N.prototype.entries=N.prototype[Symbol.iterator]=function(){return X(this)};var Q=function(e){return e.key},ee=n.keys=function(e){return J(e,Q)};N.prototype.keys=function(){return ee(this)};var te=function(e){return e.value},ne=n.values=N.prototype.values=function(e){return J(e,te)};N.prototype.values=function(){return ne(this)};var oe=n.fold=function(e,t,n){var o=n._root;if(1===o.type)return e(t,o.value,o.key);for(var r=[o.children],a=void 0;a=r.pop();)for(var s=0,i=a.length;s<i;){var u=a[s++];u&&u.type&&(1===u.type?t=e(t,u.value,u.key):r.push(u.children))}return t};N.prototype.fold=function(e,t){return oe(e,t,this)};var re=n.forEach=function(e,t){return oe((function(n,o,r){return e(o,r,t)}),null,t)};N.prototype.forEach=function(e){return re(e,this)};var ae=n.count=function(e){return e._size};N.prototype.count=function(){return ae(this)},Object.defineProperty(N.prototype,"size",{get:N.prototype.count}),e.exports?e.exports=n:(void 0).hamt=n}));class ne{constructor(e){l(this,"_map",void 0),this._map=new Map(null===e||void 0===e?void 0:e.entries())}keys(){return this._map.keys()}entries(){return this._map.entries()}get(e){return this._map.get(e)}has(e){return this._map.has(e)}set(e,t){return this._map.set(e,t),this}delete(e){return this._map.delete(e),this}clone(){return re(this)}toMap(){return new Map(this._map)}}class oe{constructor(e){if(l(this,"_hamt",te.empty.beginMutation()),e instanceof oe){const t=e._hamt.endMutation();e._hamt=t.beginMutation(),this._hamt=t.beginMutation()}else if(e)for(const[t,n]of e.entries())this._hamt.set(t,n)}keys(){return this._hamt.keys()}entries(){return this._hamt.entries()}get(e){return this._hamt.get(e)}has(e){return this._hamt.has(e)}set(e,t){return this._hamt.set(e,t),this}delete(e){return this._hamt.delete(e),this}clone(){return re(this)}toMap(){return new Map(this._hamt)}}function re(e){return W("recoil_hamt_2020")?new oe(e):new ne(e)}var ae=re,se=Object.freeze({__proto__:null,persistentMap:ae});var ie=function(e,...t){const n=new Set;e:for(const o of e){for(const e of t)if(e.has(o))continue e;n.add(o)}return n};var ue=function(e,t){const n=new Map;return e.forEach(((e,o)=>{n.set(o,t(e,o))})),n};function ce(e,t,n){const{nodeDeps:o,nodeToNodeSubscriptions:r}=t;e.forEach(((e,t)=>{const a=o.get(t);if(a&&n&&a!==n.nodeDeps.get(t))return;o.set(t,new Set(e));if((null==a?e:ie(e,a)).forEach((e=>{r.has(e)||r.set(e,new Set);c(r.get(e)).add(t)})),a){ie(a,e).forEach((e=>{if(!r.has(e))return;const n=c(r.get(e));n.delete(t),0===n.size&&r.delete(e)}))}}))}var le={addToDependencyMap:function(e,t,n){n.has(e)||n.set(e,new Set),c(n.get(e)).add(t)},cloneGraph:function(e){return{nodeDeps:ue(e.nodeDeps,(e=>new Set(e))),nodeToNodeSubscriptions:ue(e.nodeToNodeSubscriptions,(e=>new Set(e)))}},graph:function(){return{nodeDeps:new Map,nodeToNodeSubscriptions:new Map}},mergeDepsIntoDependencyMap:function(e,t){e.forEach(((e,n)=>{t.has(n)||t.set(n,new Set);const o=c(t.get(n));e.forEach((e=>o.add(e)))}))},saveDependencyMapToStore:function(e,t,n){var o,r,a,s;const i=t.getState();n!==i.currentTree.version&&n!==(null===(o=i.nextTree)||void 0===o?void 0:o.version)&&n!==(null===(r=i.previousTree)||void 0===r?void 0:r.version)&&j("Tried to save dependencies to a discarded tree");const u=t.getGraph(n);if(ce(e,u),n===(null===(a=i.previousTree)||void 0===a?void 0:a.version)){ce(e,t.getGraph(i.currentTree.version),u)}if(n===(null===(s=i.previousTree)||void 0===s?void 0:s.version)||n===i.currentTree.version){var c;const n=null===(c=i.nextTree)||void 0===c?void 0:c.version;if(void 0!==n){ce(e,t.getGraph(n),u)}}}};let de=0;let fe=0;let he=0;var pe={getNextTreeStateVersion:()=>de++,getNextStoreID:()=>fe++,getNextComponentID:()=>he++};const{persistentMap:ve}=se,{graph:ye}=le,{getNextTreeStateVersion:me}=pe;function _e(){const e=me();return{version:e,stateID:e,transactionMetadata:{},dirtyAtoms:new Set,atomValues:ve(),nonvalidatedAtoms:ve()}}var ge={makeEmptyTreeState:_e,makeEmptyStoreState:function(){const e=_e();return{currentTree:e,nextTree:null,previousTree:null,commitDepth:0,knownAtoms:new Set,knownSelectors:new Set,transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(e.version,ye()),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map}},getNextTreeStateVersion:me};class Se{}var be={RetentionZone:Se,retentionZone:function(){return new Se}};var Te={setByAddingToSet:function(e,t){const n=new Set(e);return n.add(t),n},setByDeletingFromSet:function(e,t){const n=new Set(e);return n.delete(t),n},mapBySettingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n),o},mapByUpdatingInMap:function(e,t,n){const o=new Map(e);return o.set(t,n(o.get(t))),o},mapByDeletingFromMap:function(e,t){const n=new Map(e);return n.delete(t),n},mapByDeletingMultipleFromMap:function(e,t){const n=new Map(e);return t.forEach((e=>n.delete(e))),n}};var Re=function*(e,t){let n=0;for(const o of e)t(o,n++)&&(yield o)};var we=function(e,t){return new Proxy(e,{get:(e,n)=>(!(n in e)&&n in t&&(e[n]=t[n]()),e[n]),ownKeys:e=>Object.keys(e)})};const{getNode:Ae,getNodeMaybe:Ee,recoilValuesForKeys:Ne}=Q,{RetentionZone:ke}=be,{setByAddingToSet:Ve}=Te,Le=Object.freeze(new Set);class Me extends Error{}function Ce(e,t,n,o){const r=e.getState();if(r.nodeCleanupFunctions.has(n))return;const a=Ae(n),s=function(e,t,n){if(!W("recoil_memory_managament_2020"))return()=>{};const{nodesRetainedByZone:o}=e.getState().retention;function r(e){let n=o.get(e);n||o.set(e,n=new Set),n.add(t)}if(n instanceof ke)r(n);else if(Array.isArray(n))for(const a of n)r(a);return()=>{if(!W("recoil_memory_managament_2020"))return;const{retention:o}=e.getState();function r(e){const n=o.nodesRetainedByZone.get(e);null===n||void 0===n||n.delete(t),n&&0===n.size&&o.nodesRetainedByZone.delete(e)}if(n instanceof ke)r(n);else if(Array.isArray(n))for(const e of n)r(e)}}(e,n,a.retainedBy),i=a.init(e,t,o);r.nodeCleanupFunctions.set(n,(()=>{i(),s()}))}function Ue(e,t,n){return Ae(n).peek(e,t)}function Be(e,t,n){const o=new Set,r=Array.from(n),a=e.getGraph(t.version);for(let i=r.pop();i;i=r.pop()){var s;o.add(i);const e=null!==(s=a.nodeToNodeSubscriptions.get(i))&&void 0!==s?s:Le;for(const t of e)o.has(t)||r.push(t)}return o}var De,Ie,Oe,xe={getNodeLoadable:function(e,t,n){return Ce(e,t,n,"get"),Ae(n).get(e,t)},peekNodeLoadable:Ue,setNodeValue:function(e,t,n,o){const r=Ae(n);if(null==r.set)throw new Me(`Attempt to set read-only RecoilValue: ${n}`);const a=r.set;return Ce(e,t,n,"set"),a(e,t,o)},initializeNode:function(e,t,n){Ce(e,e.getState().currentTree,t,n)},cleanUpNode:function(e,t){var n;const o=e.getState();null===(n=o.nodeCleanupFunctions.get(t))||void 0===n||n(),o.nodeCleanupFunctions.delete(t)},setUnvalidatedAtomValue_DEPRECATED:function(e,t,n){var o;const r=Ee(t);return null===r||void 0===r||null===(o=r.invalidate)||void 0===o||o.call(r,e),{...e,atomValues:e.atomValues.clone().delete(t),nonvalidatedAtoms:e.nonvalidatedAtoms.clone().set(t,n),dirtyAtoms:Ve(e.dirtyAtoms,t)}},peekNodeInfo:function(e,t,n){const o=e.getState(),r=e.getGraph(t.version),a=Ae(n).nodeType;return we({type:a},{loadable:()=>Ue(e,t,n),isActive:()=>o.knownAtoms.has(n)||o.knownSelectors.has(n),isSet:()=>"selector"!==a&&t.atomValues.has(n),isModified:()=>t.dirtyAtoms.has(n),deps:()=>{var e;return Ne(null!==(e=r.nodeDeps.get(n))&&void 0!==e?e:[])},subscribers:()=>{var r,a;return{nodes:Ne(Re(Be(e,t,new Set([n])),(e=>e!==n))),components:$(null!==(r=null===(a=o.nodeToComponentSubscriptions.get(n))||void 0===a?void 0:a.values())&&void 0!==r?r:[],(([e])=>({name:e})))}}})},getDownstreamNodes:Be};const Pe=null!==(De=r.a.createMutableSource)&&void 0!==De?De:r.a.unstable_createMutableSource,ze=null!==(Ie=r.a.useMutableSource)&&void 0!==Ie?Ie:r.a.unstable_useMutableSource,Fe=null!==(Oe=r.a.useSyncExternalStore)&&void 0!==Oe?Oe:r.a.unstable_useSyncExternalStore;var We={createMutableSource:Pe,useMutableSource:ze,useSyncExternalStore:Fe,reactMode:function(){return W("recoil_transition_support")?{mode:"TRANSITION_SUPPORT",early:!0,concurrent:!0}:W("recoil_sync_external_store")&&null!=Fe?{mode:"SYNC_EXTERNAL_STORE",early:!0,concurrent:!1}:W("recoil_mutable_source")&&null!=ze&&"undefined"!==typeof window&&!window.$disableRecoilValueMutableSource_TEMP_HACK_DO_NOT_USE?W("recoil_suppress_rerender_in_callback")?{mode:"MUTABLE_SOURCE",early:!0,concurrent:!0}:{mode:"MUTABLE_SOURCE",early:!1,concurrent:!1}:W("recoil_suppress_rerender_in_callback")?{mode:"LEGACY",early:!0,concurrent:!1}:{mode:"LEGACY",early:!1,concurrent:!1}}};const{getDownstreamNodes:$e,getNodeLoadable:je,setNodeValue:Ge}=xe,{getNextComponentID:qe}=pe,{getNode:He,getNodeMaybe:Ke}=Q,{DefaultValue:Ze,RecoilValueNotReady:Je}=Q,{reactMode:Ye}=We,{AbstractRecoilValue:Xe,RecoilState:Qe,RecoilValueReadOnly:et,isRecoilValue:tt}=x;function nt(e,t,n){if("set"===n.type){const{recoilValue:o,valueOrUpdater:r}=n,a=function(e,t,{key:n},o){if("function"===typeof o){const r=je(e,t,n);if("loading"===r.state)throw new Je(n);if("hasError"===r.state)throw r.contents;return o(r.contents)}return o}(e,t,o,r),s=Ge(e,t,o.key,a);for(const[e,n]of s.entries())ot(t,e,n)}else if("setLoadable"===n.type){const{recoilValue:{key:e},loadable:o}=n;ot(t,e,o)}else if("markModified"===n.type){const{recoilValue:{key:e}}=n;t.dirtyAtoms.add(e)}else if("setUnvalidated"===n.type){var o;const{recoilValue:{key:e},unvalidatedValue:r}=n,a=Ke(e);null===a||void 0===a||null===(o=a.invalidate)||void 0===o||o.call(a,t),t.atomValues.delete(e),t.nonvalidatedAtoms.set(e,r),t.dirtyAtoms.add(e)}else j(`Unknown action ${n.type}`)}function ot(e,t,n){"hasValue"===n.state&&n.contents instanceof Ze?e.atomValues.delete(t):e.atomValues.set(t,n),e.dirtyAtoms.add(t),e.nonvalidatedAtoms.delete(t)}function rt(e,t){e.replaceState((n=>{const o=it(n);for(const r of t)nt(e,o,r);return ut(e,o),o}))}function at(e,t){if(st.length){const n=st[st.length-1];let o=n.get(e);o||n.set(e,o=[]),o.push(t)}else rt(e,[t])}const st=[];function it(e){return{...e,atomValues:e.atomValues.clone(),nonvalidatedAtoms:e.nonvalidatedAtoms.clone(),dirtyAtoms:new Set(e.dirtyAtoms)}}function ut(e,t){const n=$e(e,t,t.dirtyAtoms);for(const a of n){var o,r;null===(o=Ke(a))||void 0===o||null===(r=o.invalidate)||void 0===r||r.call(o,t)}}function ct(e,t,n){at(e,{type:"set",recoilValue:t,valueOrUpdater:n})}var lt={RecoilValueReadOnly:et,AbstractRecoilValue:Xe,RecoilState:Qe,getRecoilValueAsLoadable:function(e,{key:t},n=e.getState().currentTree){var o,r;const a=e.getState();n.version!==a.currentTree.version&&n.version!==(null===(o=a.nextTree)||void 0===o?void 0:o.version)&&n.version!==(null===(r=a.previousTree)||void 0===r?void 0:r.version)&&j("Tried to read from a discarded tree");const s=je(e,n,t);return"loading"===s.state&&s.contents.catch((()=>{})),s},setRecoilValue:ct,setRecoilValueLoadable:function(e,t,n){if(n instanceof Ze)return ct(e,t,n);at(e,{type:"setLoadable",recoilValue:t,loadable:n})},markRecoilValueModified:function(e,t){at(e,{type:"markModified",recoilValue:t})},setUnvalidatedRecoilValue:function(e,t,n){at(e,{type:"setUnvalidated",recoilValue:t,unvalidatedValue:n})},subscribeToRecoilValue:function(e,{key:t},n,o=null){const r=qe(),a=e.getState();a.nodeToComponentSubscriptions.has(t)||a.nodeToComponentSubscriptions.set(t,new Map),c(a.nodeToComponentSubscriptions.get(t)).set(r,[null!==o&&void 0!==o?o:"<not captured>",n]);const s=Ye();if(s.early&&("LEGACY"===s.mode||"MUTABLE_SOURCE"===s.mode)){const o=e.getState().nextTree;o&&o.dirtyAtoms.has(t)&&n(o)}return{release:()=>{const n=e.getState(),o=n.nodeToComponentSubscriptions.get(t);void 0!==o&&o.has(r)?(o.delete(r),0===o.size&&n.nodeToComponentSubscriptions.delete(t)):j(`Subscription missing at release time for atom ${t}. This is a bug in Recoil.`)}}},isRecoilValue:tt,applyAtomValueWrites:function(e,t){const n=e.clone();return t.forEach(((e,t)=>{"hasValue"===e.state&&e.contents instanceof Ze?n.delete(t):n.set(t,e)})),n},batchStart:function(){const e=new Map;return st.push(e),()=>{for(const[t,n]of e)rt(t,n);st.pop()!==e&&j("Incorrect order of batch popping")}},writeLoadableToTreeState:ot,invalidateDownstreams:ut,copyTreeState:it,refreshRecoilValue:function(e,t){var n;const{currentTree:o}=e.getState(),r=He(t.key);null===(n=r.clearCache)||void 0===n||n.call(r,e,o)},invalidateDownstreams_FOR_TESTING:ut};var dt=function(e,t,n){const o=e.entries();let r=o.next();for(;!r.done;){const a=r.value;if(t.call(n,a[1],a[0],e))return!0;r=o.next()}return!1};const{cleanUpNode:ft}=xe,{deleteNodeConfigIfPossible:ht,getNode:pt}=Q,{RetentionZone:vt}=be,yt=new Set;function mt(e,t){const n=e.getState(),o=n.currentTree;if(n.nextTree)return void j("releaseNodesNowOnCurrentTree should only be called at the end of a batch");const r=new Set;for(const s of t)if(s instanceof vt)for(const e of gt(n,s))r.add(e);else r.add(s);const a=function(e,t){const n=e.getState(),o=n.currentTree,r=e.getGraph(o.version),a=new Set,s=new Set;return i(t),a;function i(t){const u=new Set,l=function(e,t,n,o,r){const a=e.getGraph(t.version),s=[],i=new Set;for(;n.size>0;)u(c(n.values().next().value));return s;function u(e){if(o.has(e)||r.has(e))return void n.delete(e);if(i.has(e))return;const t=a.nodeToNodeSubscriptions.get(e);if(t)for(const n of t)u(n);i.add(e),n.delete(e),s.push(e)}}(e,o,t,a,s);for(const e of l){var d;if("recoilRoot"===pt(e).retainedBy){s.add(e);continue}if((null!==(d=n.retention.referenceCounts.get(e))&&void 0!==d?d:0)>0){s.add(e);continue}if(St(e).some((e=>n.retention.referenceCounts.get(e)))){s.add(e);continue}const t=r.nodeToNodeSubscriptions.get(e);t&&dt(t,(e=>s.has(e)))?s.add(e):(a.add(e),u.add(e))}const f=new Set;for(const e of u)for(const t of null!==(h=r.nodeDeps.get(e))&&void 0!==h?h:yt){var h;a.has(t)||f.add(t)}f.size&&i(f)}}(e,r);for(const s of a)_t(e,o,s)}function _t(e,t,n){if(!W("recoil_memory_managament_2020"))return;ft(e,n);const o=e.getState();o.knownAtoms.delete(n),o.knownSelectors.delete(n),o.nodeTransactionSubscriptions.delete(n),o.retention.referenceCounts.delete(n);const r=St(n);for(const u of r){var a;null===(a=o.retention.nodesRetainedByZone.get(u))||void 0===a||a.delete(n)}t.atomValues.delete(n),t.dirtyAtoms.delete(n),t.nonvalidatedAtoms.delete(n);const s=o.graphsByVersion.get(t.version);if(s){const e=s.nodeDeps.get(n);if(void 0!==e){s.nodeDeps.delete(n);for(const t of e){var i;null===(i=s.nodeToNodeSubscriptions.get(t))||void 0===i||i.delete(n)}}s.nodeToNodeSubscriptions.delete(n)}ht(n)}function gt(e,t){var n;return null!==(n=e.retention.nodesRetainedByZone.get(t))&&void 0!==n?n:yt}function St(e){const t=pt(e).retainedBy;return void 0===t||"components"===t||"recoilRoot"===t?[]:t instanceof vt?[t]:t}function bt(e,t){if(!W("recoil_memory_managament_2020"))return;e.getState().retention.referenceCounts.delete(t),function(e,t){const n=e.getState();n.nextTree?n.retention.retainablesToCheckForRelease.add(t):mt(e,new Set([t]))}(e,t)}var Tt={SUSPENSE_TIMEOUT_MS:12e4,updateRetainCount:function(e,t,n){var o;if(!W("recoil_memory_managament_2020"))return;const r=e.getState().retention.referenceCounts,a=(null!==(o=r.get(t))&&void 0!==o?o:0)+n;0===a?bt(e,t):r.set(t,a)},updateRetainCountToZero:bt,releaseScheduledRetainablesNow:function(e){if(!W("recoil_memory_managament_2020"))return;const t=e.getState();mt(e,t.retention.retainablesToCheckForRelease),t.retention.retainablesToCheckForRelease.clear()},retainedByOptionWithDefault:function(e){return void 0===e?"recoilRoot":e}};const{unstable_batchedUpdates:Rt}=s.a;var wt={unstable_batchedUpdates:Rt};const{unstable_batchedUpdates:At}=wt;var Et={unstable_batchedUpdates:At};const{batchStart:Nt}=lt,{unstable_batchedUpdates:kt}=Et;let Vt=kt;var Lt={getBatcher:()=>Vt,setBatcher:e=>{Vt=e},batchUpdates:e=>{Vt((()=>{let t=()=>{};try{t=Nt(),e()}finally{t()}}))}};var Mt=function*(e){for(const t of e)for(const e of t)yield e};var Ct={isSSR:"undefined"===typeof window,isReactNative:"undefined"!==typeof navigator&&"ReactNative"===navigator.product};var Ut={memoizeWithArgsHash:function(e,t){let n;return(...o)=>{n||(n={});const r=t(...o);return Object.hasOwnProperty.call(n,r)||(n[r]=e.apply(this,o)),n[r]}},memoizeOneWithArgsHash:function(e,t){let n,o;return(...r)=>{const a=t(...r);return n===a||(n=a,o=e.apply(this,r)),o}},memoizeOneWithArgsHashAndInvalidation:function(e,t){let n,o;return[(...r)=>{const a=t(...r);return n===a||(n=a,o=e.apply(this,r)),o},()=>{n=null}]}};const{batchUpdates:Bt}=Lt,{initializeNode:Dt,peekNodeInfo:It}=xe,{graph:Ot}=le,{getNextStoreID:xt}=pe,{DEFAULT_VALUE:Pt,recoilValues:zt,recoilValuesForKeys:Ft}=Q,{AbstractRecoilValue:Wt,getRecoilValueAsLoadable:$t,setRecoilValue:jt,setUnvalidatedRecoilValue:Gt}=lt,{updateRetainCount:qt}=Tt,{getNextTreeStateVersion:Ht,makeEmptyStoreState:Kt}=ge,{isSSR:Zt}=Ct,{memoizeOneWithArgsHashAndInvalidation:Jt}=Ut;class Yt{constructor(e){l(this,"_store",void 0),l(this,"_refCount",1),l(this,"getLoadable",(e=>(this.checkRefCount_INTERNAL(),$t(this._store,e)))),l(this,"getPromise",(e=>(this.checkRefCount_INTERNAL(),this.getLoadable(e).toPromise()))),l(this,"getNodes_UNSTABLE",(e=>{if(this.checkRefCount_INTERNAL(),!0===(null===e||void 0===e?void 0:e.isModified)){if(!1===(null===e||void 0===e?void 0:e.isInitialized))return[];const t=this._store.getState().currentTree;return Ft(t.dirtyAtoms)}const t=this._store.getState().knownAtoms,n=this._store.getState().knownSelectors;return null==(null===e||void 0===e?void 0:e.isInitialized)?zt.values():!0===e.isInitialized?Ft(Mt([this._store.getState().knownAtoms,this._store.getState().knownSelectors])):Re(zt.values(),(({key:e})=>!t.has(e)&&!n.has(e)))})),l(this,"getInfo_UNSTABLE",(({key:e})=>(this.checkRefCount_INTERNAL(),It(this._store,this._store.getState().currentTree,e)))),l(this,"map",(e=>{this.checkRefCount_INTERNAL();const t=new tn(this,Bt);return e(t),t})),l(this,"asyncMap",(async e=>{this.checkRefCount_INTERNAL();const t=new tn(this,Bt);return t.retain(),await e(t),t.autoRelease_INTERNAL(),t})),this._store={storeID:xt(),getState:()=>e,replaceState:t=>{e.currentTree=t(e.currentTree)},getGraph:t=>{const n=e.graphsByVersion;if(n.has(t))return c(n.get(t));const o=Ot();return n.set(t,o),o},subscribeToTransactions:()=>({release:()=>{}}),addTransactionMetadata:()=>{throw i("Cannot subscribe to Snapshots")}};for(const t of this._store.getState().knownAtoms)Dt(this._store,t,"get"),qt(this._store,t,1);this.autoRelease_INTERNAL()}retain(){this._refCount<=0&&j("Attempt to retain() Snapshot that was already released."),this._refCount++;let e=!1;return()=>{e||(e=!0,this._release())}}autoRelease_INTERNAL(){Zt||window.setTimeout((()=>this._release()),0)}_release(){if(this._refCount--,0===this._refCount){if(this._store.getState().nodeCleanupFunctions.forEach((e=>e())),this._store.getState().nodeCleanupFunctions.clear(),!W("recoil_memory_managament_2020"))return}else this._refCount}isRetained(){return this._refCount>0}checkRefCount_INTERNAL(){W("recoil_memory_managament_2020")&&this._refCount}getStore_INTERNAL(){return this.checkRefCount_INTERNAL(),this._store}getID(){return this.checkRefCount_INTERNAL(),this._store.getState().currentTree.stateID}}function Xt(e,t,n=!1){const o=e.getState(),r=n?Ht():t.version;return{currentTree:n?{version:r,stateID:r,transactionMetadata:{...t.transactionMetadata},dirtyAtoms:new Set(t.dirtyAtoms),atomValues:t.atomValues.clone(),nonvalidatedAtoms:t.nonvalidatedAtoms.clone()}:t,commitDepth:0,nextTree:null,previousTree:null,knownAtoms:new Set(o.knownAtoms),knownSelectors:new Set(o.knownSelectors),transactionSubscriptions:new Map,nodeTransactionSubscriptions:new Map,nodeToComponentSubscriptions:new Map,queuedComponentCallbacks_DEPRECATED:[],suspendedComponentResolvers:new Set,graphsByVersion:(new Map).set(r,e.getGraph(t.version)),retention:{referenceCounts:new Map,nodesRetainedByZone:new Map,retainablesToCheckForRelease:new Set},nodeCleanupFunctions:new Map($(o.nodeCleanupFunctions.entries(),(([e])=>[e,()=>{}])))}}const[Qt,en]=Jt(((e,t)=>{const n=e.getState(),o="current"===t?n.currentTree:c(n.previousTree);return new Yt(Xt(e,o))}),((e,t)=>{var n;return String(t)+String(e.storeID)+String(e.getState().currentTree.version)+String(null===(n=e.getState().previousTree)||void 0===n?void 0:n.version)}));class tn extends Yt{constructor(e,t){super(Xt(e.getStore_INTERNAL(),e.getStore_INTERNAL().getState().currentTree,!0)),l(this,"_batch",void 0),l(this,"set",((e,t)=>{this.checkRefCount_INTERNAL();const n=this.getStore_INTERNAL();this._batch((()=>{qt(n,e.key,1),jt(this.getStore_INTERNAL(),e,t)}))})),l(this,"reset",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();this._batch((()=>{qt(t,e.key,1),jt(this.getStore_INTERNAL(),e,Pt)}))})),l(this,"setUnvalidatedAtomValues_DEPRECATED",(e=>{this.checkRefCount_INTERNAL();const t=this.getStore_INTERNAL();Bt((()=>{for(const[n,o]of e.entries())qt(t,n,1),Gt(t,new Wt(n),o)}))})),this._batch=t}}var nn={Snapshot:Yt,MutableSnapshot:tn,freshSnapshot:function(e){const t=new Yt(Kt());return null!=e?t.map(e):t},cloneSnapshot:function(e,t="current"){const n=Qt(e,t);return n.isRetained()?n:(en(),Qt(e,t))}},on=nn.Snapshot,rn=nn.MutableSnapshot,an=nn.freshSnapshot,sn=nn.cloneSnapshot,un=Object.freeze({__proto__:null,Snapshot:on,MutableSnapshot:rn,freshSnapshot:an,cloneSnapshot:sn});var cn=function(...e){const t=new Set;for(const n of e)for(const e of n)t.add(e);return t};const{useRef:ln}=r.a;var dn=function(e){const t=ln(e);return t.current===e&&"function"===typeof e&&(t.current=e()),t};const{getNextTreeStateVersion:fn,makeEmptyStoreState:hn}=ge,{cleanUpNode:pn,getDownstreamNodes:vn,initializeNode:yn,setNodeValue:mn,setUnvalidatedAtomValue_DEPRECATED:_n}=xe,{graph:gn}=le,{cloneGraph:Sn}=le,{getNextStoreID:bn}=pe,{createMutableSource:Tn,reactMode:Rn}=We,{applyAtomValueWrites:wn}=lt,{releaseScheduledRetainablesNow:An}=Tt,{freshSnapshot:En}=un,{useCallback:Nn,useContext:kn,useEffect:Vn,useMemo:Ln,useRef:Mn,useState:Cn}=r.a;function Un(){throw i("This component must be used inside a <RecoilRoot> component.")}const Bn=Object.freeze({storeID:bn(),getState:Un,replaceState:Un,getGraph:Un,subscribeToTransactions:Un,addTransactionMetadata:Un});let Dn=!1;function In(e){if(Dn)throw i("An atom update was triggered within the execution of a state updater function. State updater functions provided to Recoil must be pure functions.");const t=e.getState();if(null===t.nextTree){W("recoil_memory_managament_2020")&&W("recoil_release_on_cascading_update_killswitch_2021")&&t.commitDepth>0&&An(e);const n=t.currentTree.version,o=fn();t.nextTree={...t.currentTree,version:o,stateID:o,dirtyAtoms:new Set,transactionMetadata:{}},t.graphsByVersion.set(o,Sn(c(t.graphsByVersion.get(n))))}}const On=r.a.createContext({current:Bn}),xn=()=>kn(On),Pn=r.a.createContext(null);function zn(e,t,n){const o=vn(e,n,n.dirtyAtoms);for(const r of o){const e=t.nodeToComponentSubscriptions.get(r);if(e)for(const[t,[o,r]]of e)r(n)}}function Fn(e){const t=e.getState(),n=t.currentTree,o=n.dirtyAtoms;if(o.size){for(const[n,r]of t.nodeTransactionSubscriptions)if(o.has(n))for(const[t,o]of r)o(e);for(const[n,o]of t.transactionSubscriptions)o(e);(!Rn().early||t.suspendedComponentResolvers.size>0)&&(zn(e,t,n),t.suspendedComponentResolvers.forEach((e=>e())),t.suspendedComponentResolvers.clear())}t.queuedComponentCallbacks_DEPRECATED.forEach((e=>e(n))),t.queuedComponentCallbacks_DEPRECATED.splice(0,t.queuedComponentCallbacks_DEPRECATED.length)}function Wn({setNotifyBatcherOfChange:e}){const t=xn(),[,n]=Cn([]);return e((()=>n({}))),Vn((()=>(e((()=>n({}))),()=>{e((()=>{}))})),[e]),Vn((()=>{ee.enqueueExecution("Batcher",(()=>{!function(e){const t=e.getState();t.commitDepth++;try{const{nextTree:n}=t;if(null===n)return;t.previousTree=t.currentTree,t.currentTree=n,t.nextTree=null,Fn(e),null!=t.previousTree?t.graphsByVersion.delete(t.previousTree.version):j("Ended batch with no previous state, which is unexpected","recoil"),t.previousTree=null,W("recoil_memory_managament_2020")&&An(e)}finally{t.commitDepth--}}(t.current)}))})),null}let $n=0;function jn({initializeState_DEPRECATED:e,initializeState:t,store_INTERNAL:n,children:o}){let a;const s=e=>{const t=a.current.graphsByVersion;if(t.has(e))return c(t.get(e));const n=gn();return t.set(e,n),n},i=(e,t)=>{if(null==t){const{transactionSubscriptions:t}=h.current.getState(),n=$n++;return t.set(n,e),{release:()=>{t.delete(n)}}}{const{nodeTransactionSubscriptions:n}=h.current.getState();n.has(t)||n.set(t,new Map);const o=$n++;return c(n.get(t)).set(o,e),{release:()=>{const e=n.get(t);e&&(e.delete(o),0===e.size&&n.delete(t))}}}},u=e=>{In(h.current);for(const t of Object.keys(e))c(h.current.getState().nextTree).transactionMetadata[t]=e[t]},l=e=>{In(h.current);const t=c(a.current.nextTree);let n;try{Dn=!0,n=e(t)}finally{Dn=!1}n!==t&&(a.current.nextTree=n,Rn().early&&zn(h.current,a.current,n),c(d.current)())},d=Mn(null),f=Nn((e=>{d.current=e}),[d]),h=dn((()=>null!==n&&void 0!==n?n:{storeID:bn(),getState:()=>a.current,replaceState:l,getGraph:s,subscribeToTransactions:i,addTransactionMetadata:u}));null!=n&&(h.current=n),a=dn((()=>null!=e?function(e,t){const n=hn();return t({set:(t,o)=>{const r=n.currentTree,a=mn(e,r,t.key,o),s=new Set(a.keys()),i=r.nonvalidatedAtoms.clone();for(const e of s)i.delete(e);n.currentTree={...r,dirtyAtoms:cn(r.dirtyAtoms,s),atomValues:wn(r.atomValues,a),nonvalidatedAtoms:i}},setUnvalidatedAtomValues:e=>{e.forEach(((e,t)=>{n.currentTree=_n(n.currentTree,t,e)}))}}),n}(h.current,e):null!=t?function(e){const t=En().map(e),n=t.getStore_INTERNAL().getState();return t.retain(),n.nodeCleanupFunctions.forEach((e=>e())),n.nodeCleanupFunctions.clear(),n}(t):hn()));const p=Ln((()=>null===Tn||void 0===Tn?void 0:Tn(a,(()=>a.current.currentTree.version))),[a]);return Vn((()=>{const e=h.current;for(const t of new Set(e.getState().knownAtoms))yn(e,t,"get");return()=>{for(const t of e.getState().knownAtoms)pn(e,t)}}),[h]),r.a.createElement(On.Provider,{value:h},r.a.createElement(Pn.Provider,{value:p},r.a.createElement(Wn,{setNotifyBatcherOfChange:f}),o))}var Gn={RecoilRoot:function(e){const{override:t,...n}=e,o=xn();return!1===t&&o.current!==Bn?e.children:r.a.createElement(jn,n)},useStoreRef:xn,useRecoilMutableSource:function(){const e=kn(Pn);return null==e&&P("Attempted to use a Recoil hook outside of a <RecoilRoot>. <RecoilRoot> must be an ancestor of any component that uses Recoil hooks."),e},useRecoilStoreID:function(){return xn().current.storeID},notifyComponents_FOR_TESTING:zn,sendEndOfBatchNotifications_FOR_TESTING:Fn};var qn=function(e,t){if(e===t)return!0;if(e.length!==t.length)return!1;for(let n=0,o=e.length;n<o;n++)if(e[n]!==t[n])return!1;return!0};const{useEffect:Hn,useRef:Kn}=r.a;var Zn=function(e){const t=Kn();return Hn((()=>{t.current=e})),t.current};const{useStoreRef:Jn}=Gn,{SUSPENSE_TIMEOUT_MS:Yn}=Tt,{updateRetainCount:Xn}=Tt,{RetentionZone:Qn}=be,{useEffect:eo,useRef:to}=r.a,{isSSR:no}=Ct;var oo=function(e){if(W("recoil_memory_managament_2020"))return function(e){const t=(Array.isArray(e)?e:[e]).map((e=>e instanceof Qn?e:e.key)),n=Jn();eo((()=>{if(!W("recoil_memory_managament_2020"))return;const e=n.current;if(o.current&&!no)window.clearTimeout(o.current),o.current=null;else for(const n of t)Xn(e,n,1);return()=>{for(const n of t)Xn(e,n,-1)}}),[n,...t]);const o=to(),r=Zn(t);if(!no&&(void 0===r||!qn(r,t))){const e=n.current;for(const n of t)Xn(e,n,1);if(r)for(const t of r)Xn(e,t,-1);o.current&&window.clearTimeout(o.current),o.current=window.setTimeout((()=>{o.current=null;for(const n of t)Xn(e,n,-1)}),Yn)}}(e)};const{useRef:ro}=r.a;var ao=function(){return ro(),"<component name not available>"};const{batchUpdates:so}=Lt,{DEFAULT_VALUE:io}=Q,{reactMode:uo,useMutableSource:co,useSyncExternalStore:lo}=We,{useRecoilMutableSource:fo,useStoreRef:ho}=Gn,{isRecoilValue:po}=x,{AbstractRecoilValue:vo,getRecoilValueAsLoadable:yo,setRecoilValue:mo,setUnvalidatedRecoilValue:_o,subscribeToRecoilValue:go}=lt,{useCallback:So,useEffect:bo,useMemo:To,useRef:Ro,useState:wo}=r.a,{setByAddingToSet:Ao}=Te;function Eo(e,t,n){if("hasValue"===e.state)return e.contents;if("loading"===e.state){throw new Promise((e=>{n.current.getState().suspendedComponentResolvers.add(e)}))}throw"hasError"===e.state?e.contents:i(`Invalid value of loadable atom "${t.key}"`)}function No(e){const t=ho(),n=ao(),o=So((()=>{var n;const o=t.current,r=o.getState(),a=uo().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return{loadable:yo(o,e,a),key:e.key}}),[t,e]),r=So((e=>{let t;return()=>{var n,o;const r=e();return null!==(n=t)&&void 0!==n&&n.loadable.is(r.loadable)&&(null===(o=t)||void 0===o?void 0:o.key)===r.key?t:(t=r,r)}}),[]),a=To((()=>r(o)),[o,r]),s=So((o=>{const r=t.current;return go(r,e,o,n).release}),[t,e,n]);return lo(s,a,a).loadable}function ko(e){const t=ho(),n=So((()=>{var n;const o=t.current,r=o.getState(),a=uo().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return yo(o,e,a)}),[t,e]),o=So((()=>n()),[n]),r=ao(),a=So(((o,a)=>{const s=t.current;return go(s,e,(()=>{if(!W("recoil_suppress_rerender_in_callback"))return a();const e=n();c.current.is(e)||a(),c.current=e}),r).release}),[t,e,r,n]),s=fo();if(null==s)throw i("Recoil hooks must be used in components contained within a <RecoilRoot> component.");const u=co(s,o,a),c=Ro(u);return bo((()=>{c.current=u})),u}function Vo(e){const t=ho(),n=ao(),o=So((()=>{var n;const o=t.current,r=o.getState(),a=uo().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return yo(o,e,a)}),[t,e]),r=So((()=>({loadable:o(),key:e.key})),[o,e.key]),a=So((e=>{const t=r();return e.loadable.is(t.loadable)&&e.key===t.key?e:t}),[r]);bo((()=>{const o=go(t.current,e,(e=>{i(a)}),n);return i(a),o.release}),[n,e,t,a]);const[s,i]=wo(r);return s.key!==e.key?r().loadable:s.loadable}function Lo(e){const t=ho(),[,n]=wo([]),o=ao(),r=So((()=>{var n;const o=t.current,r=o.getState(),a=uo().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree;return yo(o,e,a)}),[t,e]),a=r(),s=Ro(a);return bo((()=>{s.current=a})),bo((()=>{const a=t.current,i=a.getState(),u=go(a,e,(e=>{var t;if(!W("recoil_suppress_rerender_in_callback"))return n([]);const o=r();null!==(t=s.current)&&void 0!==t&&t.is(o)||n(o),s.current=o}),o);if(i.nextTree)a.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{s.current=null,n([])}));else{var c;if(!W("recoil_suppress_rerender_in_callback"))return n([]);const e=r();null!==(c=s.current)&&void 0!==c&&c.is(e)||n(e),s.current=e}return u.release}),[o,r,e,t]),a}function Mo(e){return W("recoil_memory_managament_2020")&&oo(e),{TRANSITION_SUPPORT:Vo,SYNC_EXTERNAL_STORE:No,MUTABLE_SOURCE:ko,LEGACY:Lo}[uo().mode](e)}function Co(e){const t=ho();return Eo(Mo(e),e,t)}function Uo(e){const t=ho();return So((n=>{mo(t.current,e,n)}),[t,e])}function Bo(e){return W("recoil_memory_managament_2020")&&oo(e),Vo(e)}function Do(e){const t=ho();return Eo(Bo(e),e,t)}var Io={recoilComponentGetRecoilValueCount_FOR_TESTING:{current:0},useRecoilInterface:function(){const e=ao(),t=ho(),[,n]=wo([]),o=Ro(new Set);o.current=new Set;const r=Ro(new Set),a=Ro(new Map),s=So((e=>{const t=a.current.get(e);t&&(t.release(),a.current.delete(e))}),[a]),i=So(((e,t)=>{a.current.has(t)&&n([])}),[]);return bo((()=>{const n=t.current;ie(o.current,r.current).forEach((t=>{if(a.current.has(t))return void P(`Double subscription to RecoilValue "${t}"`);const o=go(n,new vo(t),(e=>i(e,t)),e);a.current.set(t,o);n.getState().nextTree?n.getState().queuedComponentCallbacks_DEPRECATED.push((()=>{i(n.getState(),t)})):i(n.getState(),t)})),ie(r.current,o.current).forEach((e=>{s(e)})),r.current=o.current})),bo((()=>{const n=a.current;return ie(o.current,new Set(n.keys())).forEach((o=>{const r=go(t.current,new vo(o),(e=>i(e,o)),e);n.set(o,r)})),()=>n.forEach(((e,t)=>s(t)))}),[e,t,s,i]),To((()=>{function e(e){return n=>{mo(t.current,e,n)}}function n(e){var n;o.current.has(e.key)||(o.current=Ao(o.current,e.key));const r=t.current.getState();return yo(t.current,e,uo().early&&null!==(n=r.nextTree)&&void 0!==n?n:r.currentTree)}function r(e){return Eo(n(e),e,t)}return{getRecoilValue:r,getRecoilValueLoadable:n,getRecoilState:function(t){return[r(t),e(t)]},getRecoilStateLoadable:function(t){return[n(t),e(t)]},getSetRecoilState:e,getResetRecoilState:function(e){return()=>mo(t.current,e,io)}}}),[o,t])},useRecoilState:function(e){return[Co(e),Uo(e)]},useRecoilStateLoadable:function(e){return[Mo(e),Uo(e)]},useRecoilValue:Co,useRecoilValueLoadable:Mo,useResetRecoilState:function(e){const t=ho();return So((()=>{mo(t.current,e,io)}),[t,e])},useSetRecoilState:Uo,useSetUnvalidatedAtomValues:function(){const e=ho();return(t,n={})=>{so((()=>{e.current.addTransactionMetadata(n),t.forEach(((t,n)=>_o(e.current,new vo(n),t)))}))}},useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:Bo,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:Do,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:function(e){return[Do(e),Uo(e)]}};var Oo=function(e,t){const n=new Map;for(const[o,r]of e)t(r,o)&&n.set(o,r);return n};var xo=function(e,t){const n=new Set;for(const o of e)t(o)&&n.add(o);return n};var Po=function(...e){const t=new Map;for(let n=0;n<e.length;n++){const o=e[n].keys();let r;for(;!(r=o.next()).done;)t.set(r.value,e[n].get(r.value))}return t};const{batchUpdates:zo}=Lt,{DEFAULT_VALUE:Fo,getNode:Wo,nodes:$o}=Q,{useStoreRef:jo}=Gn,{AbstractRecoilValue:Go,setRecoilValueLoadable:qo}=lt,{SUSPENSE_TIMEOUT_MS:Ho}=Tt,{cloneSnapshot:Ko}=un,{useCallback:Zo,useEffect:Jo,useRef:Yo,useState:Xo}=r.a,{isSSR:Qo}=Ct;function er(e){const t=jo();Jo((()=>t.current.subscribeToTransactions(e).release),[e,t])}function tr(e){const t=e.atomValues.toMap(),n=ue(Oo(t,((e,t)=>{const n=Wo(t).persistence_UNSTABLE;return null!=n&&"none"!==n.type&&"hasValue"===e.state})),(e=>e.contents));return Po(e.nonvalidatedAtoms.toMap(),n)}function nr(e,t){var n;const o=e.getState(),r=null!==(n=o.nextTree)&&void 0!==n?n:o.currentTree,a=t.getStore_INTERNAL().getState().currentTree;zo((()=>{const n=new Set;for(const e of[r.atomValues.keys(),a.atomValues.keys()])for(const t of e){var o,s;(null===(o=r.atomValues.get(t))||void 0===o?void 0:o.contents)!==(null===(s=a.atomValues.get(t))||void 0===s?void 0:s.contents)&&Wo(t).shouldRestoreFromSnapshots&&n.add(t)}n.forEach((t=>{qo(e,new Go(t),a.atomValues.has(t)?c(a.atomValues.get(t)):Fo)})),e.replaceState((e=>({...e,stateID:t.getID()})))}))}var or={useRecoilSnapshot:function(){const e=jo(),[t,n]=Xo((()=>Ko(e.current))),o=Zn(t),r=Yo(),a=Yo();if(er(Zo((e=>n(Ko(e))),[])),Jo((()=>{const e=t.retain();var n;r.current&&!Qo&&(window.clearTimeout(r.current),r.current=null,null===(n=a.current)||void 0===n||n.call(a),a.current=null);return e}),[t]),o!==t&&!Qo){var s;if(r.current)window.clearTimeout(r.current),r.current=null,null===(s=a.current)||void 0===s||s.call(a),a.current=null;a.current=t.retain(),r.current=window.setTimeout((()=>{var e;r.current=null,null===(e=a.current)||void 0===e||e.call(a),a.current=null}),Ho)}return t},gotoSnapshot:nr,useGotoRecoilSnapshot:function(){const e=jo();return Zo((t=>nr(e.current,t)),[e])},useRecoilTransactionObserver:function(e){er(Zo((t=>{const n=Ko(t,"current"),o=Ko(t,"previous");e({snapshot:n,previousSnapshot:o})}),[e]))},useTransactionObservation_DEPRECATED:function(e){er(Zo((t=>{let n=t.getState().previousTree;const o=t.getState().currentTree;n||(j("Transaction subscribers notified without a previous tree being present -- this is a bug in Recoil"),n=t.getState().currentTree);const r=tr(o),a=tr(n),s=ue($o,(e=>{var t,n,o,r;return{persistence_UNSTABLE:{type:null!==(t=null===(n=e.persistence_UNSTABLE)||void 0===n?void 0:n.type)&&void 0!==t?t:"none",backButton:null!==(o=null===(r=e.persistence_UNSTABLE)||void 0===r?void 0:r.backButton)&&void 0!==o&&o}}})),i=xo(o.dirtyAtoms,(e=>r.has(e)||a.has(e)));e({atomValues:r,previousAtomValues:a,atomInfo:s,modifiedAtoms:i,transactionMetadata:{...o.transactionMetadata}})}),[e]))},useTransactionSubscription_DEPRECATED:er};const{peekNodeInfo:rr}=xe,{useStoreRef:ar}=Gn;var sr=function(){const e=ar();return({key:t})=>rr(e.current,e.current.getState().currentTree,t)};const{reactMode:ir}=We,{RecoilRoot:ur,useStoreRef:cr}=Gn,{useMemo:lr}=r.a;var dr=function(){"MUTABLE_SOURCE"===ir().mode&&console.warn("Warning: There are known issues using useRecoilBridgeAcrossReactRoots() in recoil_mutable_source rendering mode.  Please consider upgrading to recoil_sync_external_store mode.");const e=cr().current;return lr((()=>function({children:t}){return r.a.createElement(ur,{store_INTERNAL:e},t)}),[e])};const{loadableWithValue:fr}=V,{initializeNode:hr}=xe,{DEFAULT_VALUE:pr,getNode:vr}=Q,{copyTreeState:yr,getRecoilValueAsLoadable:mr,invalidateDownstreams:_r,writeLoadableToTreeState:gr}=lt;function Sr(e){return"atom"===vr(e.key).nodeType}class br{constructor(e,t){l(this,"_store",void 0),l(this,"_treeState",void 0),l(this,"_changes",void 0),l(this,"get",(e=>{if(this._changes.has(e.key))return this._changes.get(e.key);if(!Sr(e))throw i("Reading selectors within atomicUpdate is not supported");const t=mr(this._store,e,this._treeState);if("hasValue"===t.state)return t.contents;throw"hasError"===t.state?t.contents:i(`Expected Recoil atom ${e.key} to have a value, but it is in a loading state.`)})),l(this,"set",((e,t)=>{if(!Sr(e))throw i("Setting selectors within atomicUpdate is not supported");if("function"===typeof t){const n=this.get(e);this._changes.set(e.key,t(n))}else hr(this._store,e.key,"set"),this._changes.set(e.key,t)})),l(this,"reset",(e=>{this.set(e,pr)})),this._store=e,this._treeState=t,this._changes=new Map}newTreeState_INTERNAL(){if(0===this._changes.size)return this._treeState;const e=yr(this._treeState);for(const[t,n]of this._changes)gr(e,t,fr(n));return _r(this._store,e),e}}var Tr=function(e){return t=>{e.replaceState((n=>{const o=new br(e,n);return t(o),o.newTreeState_INTERNAL()}))}},Rr=Object.freeze({__proto__:null,atomicUpdater:Tr});var wr=function(e,t){if(!e)throw new Error(t)};const{atomicUpdater:Ar}=Rr,{batchUpdates:Er}=Lt,{DEFAULT_VALUE:Nr}=Q,{useStoreRef:kr}=Gn,{refreshRecoilValue:Vr,setRecoilValue:Lr}=lt,{Snapshot:Mr,cloneSnapshot:Cr}=un,{gotoSnapshot:Ur}=or,{useCallback:Br}=r.a;class Dr{}const Ir=new Dr;function Or(e,t,n,o){let r=Ir;return Er((()=>{const a="useRecoilCallback() expects a function that returns a function: it accepts a function of the type (RecoilInterface) => (Args) => ReturnType and returns a callback function (Args) => ReturnType, where RecoilInterface is an object {snapshot, set, ...} and Args and ReturnType are the argument and return types of the callback you want to create.  Please see the docs at recoiljs.org for details.";if("function"!==typeof t)throw i(a);const s=we({...null!==o&&void 0!==o?o:{},set:(t,n)=>Lr(e,t,n),reset:t=>Lr(e,t,Nr),refresh:t=>Vr(e,t),gotoSnapshot:t=>Ur(e,t),transact_UNSTABLE:t=>Ar(e)(t)},{snapshot:()=>Cr(e)}),u=t(s);if("function"!==typeof u)throw i(a);r=u(...n)})),r instanceof Dr&&wr(!1),r}var xr={recoilCallback:Or,useRecoilCallback:function(e,t){const n=kr();return Br(((...t)=>Or(n.current,e,t)),null!=t?[...t,n]:void 0)}};const{useStoreRef:Pr}=Gn,{refreshRecoilValue:zr}=lt,{useCallback:Fr}=r.a;var Wr=function(e){const t=Pr();return Fr((()=>{const n=t.current;zr(n,e)}),[e,t])};const{atomicUpdater:$r}=Rr,{useStoreRef:jr}=Gn,{useMemo:Gr}=r.a;var qr=function(e,t){const n=jr();return Gr((()=>(...t)=>{$r(n.current)((n=>{e(n)(...t)}))}),null!=t?[...t,n]:void 0)};const Hr=(e,t,n)=>{var o;if(null==e)return;if(null===n||void 0===n||null===(o=n.onNodeVisit)||void 0===o||o.call(n,e),"leaf"===e.type)return e;const r=t(e.nodeKey);return Hr(e.branches.get(r),t,n)},Kr=(e,t,n,o,r,a,s)=>{var i;let u;if(null==e)if(0===t.length)u={type:"leaf",value:o,parent:n,branchKey:r};else{const[e,...i]=t,[c,l]=e;u={type:"branch",nodeKey:c,parent:n,branches:new Map,branchKey:r},u.branches.set(l,Kr(null,i,u,o,l,a,s))}else if(u=e,t.length){const[n,...r]=t,[i,c]=n;if("branch"!==e.type||e.nodeKey!==i)return j("Existing cache must have a branch midway through the route with matching node key. Resetting cache."),s(),u;e.branches.set(c,Kr(e.branches.get(c),r,e,o,c,a,s))}return null===a||void 0===a||null===(i=a.onNodeVisit)||void 0===i||i.call(a,u),u},Zr=(e,t,n)=>n?(n.branches.delete(t.branchKey),Jr(e,n,n.parent)):e===t,Jr=(e,t,n)=>n?(0===t.branches.size&&n.branches.delete(t.branchKey),Jr(e,n,n.parent)):e===t,Yr=e=>"leaf"===e.type?1:Array.from(e.branches.values()).reduce(((e,t)=>e+Yr(t)),0);var Xr=class{constructor(e){var t,n,o;l(this,"_numLeafs",void 0),l(this,"_root",void 0),l(this,"_onHit",void 0),l(this,"_onSet",void 0),l(this,"_mapNodeValue",void 0),this._numLeafs=0,this._root=null,this._onHit=null!==(t=null===e||void 0===e?void 0:e.onHit)&&void 0!==t?t:()=>{},this._onSet=null!==(n=null===e||void 0===e?void 0:e.onSet)&&void 0!==n?n:()=>{},this._mapNodeValue=null!==(o=null===e||void 0===e?void 0:e.mapNodeValue)&&void 0!==o?o:e=>e}size(){return this._numLeafs}root(){return this._root}get(e,t){var n;return null===(n=this.getLeafNode(e,t))||void 0===n?void 0:n.value}getLeafNode(e,t){return Hr(this.root(),(t=>this._mapNodeValue(e(t))),{onNodeVisit:e=>{null===t||void 0===t||t.onNodeVisit(e),"leaf"===e.type&&this._onHit(e)}})}set(e,t,n){let o,r=null;const a=()=>{r=Kr(this.root(),e.map((([e,t])=>[e,this._mapNodeValue(t)])),null,t,null,{onNodeVisit:e=>{null===n||void 0===n||n.onNodeVisit(e),"leaf"===e.type&&(o=e)}},(()=>{this.clear(),a()}))};a(),this.root()||(this._root=r),this._numLeafs++,this._onSet(c(o))}delete(e){if(!this.root())return!1;const t=c(this.root());return!!Zr(t,e,e.parent)&&(e===t||"branch"===t.type&&!t.branches.size?(this._root=null,this._numLeafs=0,!0):(this._numLeafs-=Yr(e),!0))}clear(){this._numLeafs=0,this._root=null}},Qr=Object.freeze({__proto__:null,TreeCache:Xr});var ea=class{constructor(e){var t;l(this,"_maxSize",void 0),l(this,"_size",void 0),l(this,"_head",void 0),l(this,"_tail",void 0),l(this,"_map",void 0),l(this,"_keyMapper",void 0),this._maxSize=e.maxSize,this._size=0,this._head=null,this._tail=null,this._map=new Map,this._keyMapper=null!==(t=e.mapKey)&&void 0!==t?t:e=>e}head(){return this._head}tail(){return this._tail}size(){return this._size}maxSize(){return this._maxSize}has(e){return this._map.has(this._keyMapper(e))}get(e){const t=this._keyMapper(e),n=this._map.get(t);if(n)return this.set(e,n.value),n.value}set(e,t){const n=this._keyMapper(e);this._map.get(n)&&this.delete(e);const o=this.head(),r={key:e,right:o,left:null,value:t};o?o.left=r:this._tail=r,this._map.set(n,r),this._head=r,this._size++,this._maybeDeleteLRU()}_maybeDeleteLRU(){this.size()>this.maxSize()&&this.deleteLru()}deleteLru(){const e=this.tail();e&&this.delete(e.key)}delete(e){const t=this._keyMapper(e);if(!this._size||!this._map.has(t))return;const n=c(this._map.get(t)),o=n.right,r=n.left;o&&(o.left=n.left),r&&(r.right=n.right),n===this.head()&&(this._head=o),n===this.tail()&&(this._tail=r),this._map.delete(t),this._size--}clear(){this._size=0,this._head=null,this._tail=null,this._map=new Map}},ta=Object.freeze({__proto__:null,LRUCache:ea});const{LRUCache:na}=ta,{TreeCache:oa}=Qr;var ra=function(e,t=(e=>e)){const n=new na({maxSize:e}),o=new oa({mapNodeValue:t,onHit:e=>{n.set(e,!0)},onSet:t=>{const r=n.tail();n.set(t,!0),r&&o.size()>e&&o.delete(r.key)}});return o};function aa(e,t,n){if("string"===typeof e&&!e.includes('"')&&!e.includes("\\"))return`"${e}"`;switch(typeof e){case"undefined":return"";case"boolean":return e?"true":"false";case"number":case"symbol":return String(e);case"string":return JSON.stringify(e);case"function":if(!0!==(null===t||void 0===t?void 0:t.allowFunctions))throw i("Attempt to serialize function in a Recoil cache key");return`__FUNCTION(${e.name})__`}if(null===e)return"null";var o;if("object"!==typeof e)return null!==(o=JSON.stringify(e))&&void 0!==o?o:"";if(u(e))return"__PROMISE__";if(Array.isArray(e))return`[${e.map(((e,n)=>aa(e,t,n.toString())))}]`;if("function"===typeof e.toJSON)return aa(e.toJSON(n),t,n);if(e instanceof Map){const o={};for(const[n,r]of e)o["string"===typeof n?n:aa(n,t)]=r;return aa(o,t,n)}return e instanceof Set?aa(Array.from(e).sort(((e,n)=>aa(e,t).localeCompare(aa(n,t)))),t,n):void 0!==Symbol&&null!=e[Symbol.iterator]&&"function"===typeof e[Symbol.iterator]?aa(Array.from(e),t,n):`{${Object.keys(e).filter((t=>void 0!==e[t])).sort().map((n=>`${aa(n,t)}:${aa(e[n],t,n)}`)).join(",")}}`}var sa=function(e,t={allowFunctions:!1}){return aa(e,t)};const{TreeCache:ia}=Qr,ua={equality:"reference",eviction:"keep-all",maxSize:1/0};var ca=function({equality:e=ua.equality,eviction:t=ua.eviction,maxSize:n=ua.maxSize}=ua){return function(e,t,n){switch(e){case"keep-all":return new ia({mapNodeValue:n});case"lru":return ra(c(t),n);case"most-recent":return ra(1,n)}throw i(`Unrecognized eviction policy ${e}`)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>sa(e)}throw i(`Unrecognized equality policy ${e}`)}(e))};const{isReactNative:la,isSSR:da}=Ct;var fa={startPerfBlock:function(e){return()=>null}};const{loadableWithError:ha,loadableWithPromise:pa,loadableWithValue:va}=V,{getNodeLoadable:ya,peekNodeLoadable:ma,setNodeValue:_a}=xe,{saveDependencyMapToStore:ga}=le,{DEFAULT_VALUE:Sa,RecoilValueNotReady:ba,getConfigDeletionHandler:Ta,getNode:Ra,registerNode:wa}=Q,{isRecoilValue:Aa}=x,{markRecoilValueModified:Ea}=lt,{retainedByOptionWithDefault:Na}=Tt,{recoilCallback:ka}=xr,{startPerfBlock:Va}=fa;class La{}const Ma=new La,Ca=[],Ua=new Map,Ba=(()=>{let e=0;return()=>e++})();var Da=function(e){let t=null;const{key:n,get:o,cachePolicy_UNSTABLE:r}=e,a=null!=e.set?e.set:void 0,s=new Set,l=ca(null!==r&&void 0!==r?r:{equality:"reference",eviction:"keep-all"}),d=Na(e.retainedBy_UNSTABLE),f=new Map;let h=0;function p(){return!W("recoil_memory_managament_2020")||h>0}function v(e){return e.getState().knownSelectors.add(n),h++,()=>{h--}}function y(){return void 0!==Ta(n)&&!p()}function m(e,t,n,o,r){C(t,o,r),T(e,t,new Set(r.keys()),n),_(e,n)}function _(e,n){M(e,n)&&L(e);const o=Ua.get(n);if(void 0!==o){for(const e of o)Ea(e,c(t));Ua.delete(n)}}function g(e,t){let n=Ua.get(t);null==n&&Ua.set(t,n=new Set),n.add(e)}function S(e,t,n){const o=e.getState().knownSelectors.has(n);if(o&&t.atomValues.has(n))return c(t.atomValues.get(n));const r=ya(e,t,n);return"loading"!==r.state&&o&&t.atomValues.set(n,r),r}function b(e,t,n,o,r,a){return t.then((o=>{if(!p())throw L(e),Ma;null!=a.loadingDepKey&&a.loadingDepPromise===t?n.atomValues.set(a.loadingDepKey,va(o)):e.getState().knownSelectors.forEach((e=>{n.atomValues.delete(e)}));const s=w(e,n);if(s&&"loading"!==s.state){if((M(e,r)||null==k(e))&&_(e,r),"hasValue"===s.state)return s.contents;throw s.contents}if(!M(e,r)){const e=E(n);if("loading"===(null===e||void 0===e?void 0:e.latestLoadable.state))return e.latestLoadable.contents}const[i,u]=R(e,n,r);if(V(e,r,u),"loading"!==i.state&&m(e,n,r,i,u),"hasError"===i.state)throw i.contents;return i.contents})).catch((t=>{if(t instanceof La)throw Ma;if(!p())throw L(e),Ma;const a=ha(t);throw m(e,n,r,a,o),t}))}function T(e,t,o,r){var a,i,u,c,l,d,f;(M(e,r)||t.version===(null===(a=e.getState())||void 0===a||null===(i=a.currentTree)||void 0===i?void 0:i.version)||t.version===(null===(u=e.getState())||void 0===u||null===(c=u.nextTree)||void 0===c?void 0:c.version))&&(ga(new Map([[n,o]]),e,null!==(l=null===(d=e.getState())||void 0===d||null===(f=d.nextTree)||void 0===f?void 0:f.version)&&void 0!==l?l:e.getState().currentTree.version),o.forEach((e=>s.add(e))))}function R(e,r,a){const s=Va(n);let c=!0;const l=()=>{s(),c=!1};let d,f,h=!1;const v={loadingDepKey:null,loadingDepPromise:null},y=new Map,_=new Set;function g(t){const{key:n}=t;!function(e,t,n,o,r){n.add(o),T(e,t,n,r)}(e,r,_,n,a);const o=S(e,r,n);switch(y.set(n,o),o.state){case"hasValue":return o.contents;case"hasError":throw o.contents;case"loading":throw v.loadingDepKey=n,v.loadingDepPromise=o.contents,o.contents}throw i("Invalid Loadable state")}T(e,r,_,a);const R=n=>(...o)=>{if(c)throw i("Callbacks from getCallback() should only be called asynchronously after the selector is evalutated.  It can be used for selectors to return objects with callbacks that can work with Recoil state without a subscription.");return null==t&&wr(!1),ka(e,n,o,{node:t})};try{d=o({get:g,getCallback:R}),d=Aa(d)?g(d):d,u(d)?d=function(e,t,n,o,r,a){return t.then((t=>{if(!p())throw L(e),Ma;const a=va(t);return m(e,n,r,a,o),t})).catch((t=>{if(!p())throw L(e),Ma;if(V(e,r,o),u(t))return b(e,t,n,o,r,a);const s=ha(t);throw m(e,n,r,s,o),t}))}(e,d,r,y,a,v).finally(l):l()}catch(w){d=w,u(d)?d=b(e,d,r,y,a,v).finally(l):(h=!0,l())}return f=h?ha(d):u(d)?pa(d):va(d),[f,y]}function w(e,t){const o=new Set,r=k(e);let a;try{a=l.get((n=>{"string"!==typeof n&&wr(!1);return S(e,t,n).contents}),{onNodeVisit:e=>{"branch"===e.type&&e.nodeKey!==n&&o.add(e.nodeKey)}})}catch(s){throw i(`Problem with cache lookup for selector "${n}": ${s.message}`)}return a&&T(e,t,o,null===r||void 0===r?void 0:r.latestExecutionId),a}function A(e,t){const n=Ba(),[o,r]=R(e,t,n);return"loading"===o.state?(!function(e,t,n,o,r){f.set(e,{depValuesDiscoveredSoFarDuringAsyncWork:o,latestExecutionId:t,latestLoadable:n,stateVersion:r.version})}(e,n,o,r,t),g(e,n)):(L(e),C(t,o,r)),o}function E(e){var t;const[,n]=null!==(t=Array.from(f.entries()).find((([t,n])=>null!=n.latestLoadable&&null!=n.latestExecutionId&&!function(e,t){var n,o;const r=k(e),a=null!==(n=null===r||void 0===r?void 0:r.depValuesDiscoveredSoFarDuringAsyncWork)&&void 0!==n?n:new Map,s=Array((null!==(o=N.get(t.version))&&void 0!==o?o:new Map).entries()),i=N.has(t.version)&&s.length===a.size&&s.every((([e,t])=>a.get(e)===t));if(null==a||t.version===(null===r||void 0===r?void 0:r.stateVersion)||i)return!1;return N.set(t.version,new Map(a)),Array.from(a).some((([n,o])=>S(e,t,n).contents!==o.contents))}(t,e))))&&void 0!==t?t:[];return n}const N=new Map;function k(e){return f.get(e)}function V(e,t,n){if(M(e,t)){const t=k(e);null!=t&&(t.depValuesDiscoveredSoFarDuringAsyncWork=n)}}function L(e){f.delete(e)}function M(e,t){var n;return t===(null===(n=k(e))||void 0===n?void 0:n.latestExecutionId)}function C(e,t,o){e.atomValues.set(n,t);try{l.set(function(e){return Array.from(e.entries()).map((([e,t])=>[e,t.contents]))}(o),t)}catch(r){throw i(`Problem with setting cache for selector "${n}": ${r.message}`)}}function U(e,t){return l.get((n=>{var o;return"string"!==typeof n&&wr(!1),null===(o=ma(e,t,n))||void 0===o?void 0:o.contents}))}function B(e,t){return function(e){if(Ca.includes(n)){const e=`Recoil selector has circular dependencies: ${Ca.slice(Ca.indexOf(n)).join(" \u2192 ")}`;return ha(i(e))}Ca.push(n);try{return e()}finally{Ca.pop()}}((()=>function(e,t){const n=w(e,t);if(null!=n)return L(e),n;const o=E(t);var r;return null!=o?("loading"===(null===(r=o.latestLoadable)||void 0===r?void 0:r.state)&&g(e,c(o.latestExecutionId)),c(o.latestLoadable)):A(e,t)}(e,t)))}function D(e){e.atomValues.delete(n)}function I(e,n){null==t&&wr(!1);for(const t of s){var o;const r=Ra(t);null===(o=r.clearCache)||void 0===o||o.call(r,e,n)}s.clear(),D(n),l.clear(),Ea(e,t)}if(null!=a){return t=wa({key:n,nodeType:"selector",peek:U,get:B,set:(e,t,n)=>{let o=!1;const r=new Map;function s({key:n}){if(o)throw i("Recoil: Async selector sets are not currently supported.");const r=S(e,t,n);if("hasValue"===r.state)return r.contents;throw"loading"===r.state?new ba(n):r.contents}function c(n,a){if(o)throw i("Recoil: Async selector sets are not currently supported.");const u="function"===typeof a?a(s(n)):a;_a(e,t,n.key,u).forEach(((e,t)=>r.set(t,e)))}const l=a({set:c,get:s,reset:function(e){c(e,Sa)}},n);if(void 0!==l)throw u(l)?i("Recoil: Async selector sets are not currently supported."):i("Recoil: selector set should be a void function.");return o=!0,r},init:v,invalidate:D,clearCache:I,shouldDeleteConfigOnRelease:y,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d})}return t=wa({key:n,nodeType:"selector",peek:U,get:B,init:v,invalidate:D,clearCache:I,shouldDeleteConfigOnRelease:y,dangerouslyAllowMutability:e.dangerouslyAllowMutability,shouldRestoreFromSnapshots:!1,retainedBy:d})};const{loadableWithError:Ia,loadableWithPromise:Oa,loadableWithValue:xa}=V,{peekNodeInfo:Pa}=xe,{DEFAULT_VALUE:za,DefaultValue:Fa,getConfigDeletionHandler:Wa,registerNode:$a,setConfigDeletionHandler:ja}=Q,{isRecoilValue:Ga}=x,{getRecoilValueAsLoadable:qa,markRecoilValueModified:Ha,setRecoilValue:Ka,setRecoilValueLoadable:Za}=lt,{retainedByOptionWithDefault:Ja}=Tt;function Ya(e){const{key:t,persistence_UNSTABLE:n}=e,o=Ja(e.retainedBy_UNSTABLE);let r,a=0,s=u(e.default)?Oa(e.default.then((e=>(s=xa(e),e))).catch((e=>{throw s=Ia(e),e}))):xa(e.default);d(e.default);const l=new Map;function d(e){return e}function f(e,n){var o,a;return null!==(o=null!==(a=n.atomValues.get(t))&&void 0!==a?a:r)&&void 0!==o?o:s}const h=$a({key:t,nodeType:"atom",peek:f,get:function(e,o){if(o.atomValues.has(t))return c(o.atomValues.get(t));if(o.nonvalidatedAtoms.has(t)){if(null!=r)return r;if(null==n)return P(`Tried to restore a persisted value for atom ${t} but it has no persistence settings.`),s;const e=o.nonvalidatedAtoms.get(t),a=n.validator(e,za),i=a instanceof Fa?s:xa(a);return r=i,r}return s},set:function(e,n,o){if(n.atomValues.has(t)){const e=c(n.atomValues.get(t));if("hasValue"===e.state&&o===e.contents)return new Map}else if(!n.nonvalidatedAtoms.has(t)&&o instanceof Fa)return new Map;return r=void 0,(new Map).set(t,xa(o))},init:function(n,o,r){var c;if(a++,n.getState().knownAtoms.add(t),"loading"===s.state){const e=()=>{var e;(null!==(e=n.getState().nextTree)&&void 0!==e?e:n.getState().currentTree).atomValues.has(t)||Ha(n,h)};s.contents.finally(e)}const d=null!==(c=e.effects)&&void 0!==c?c:e.effects_UNSTABLE;if(null!=d){let e=!0,a=za,c=!1,S=null;function p(r){if(e&&r.key===t){const e=a;return e instanceof Fa?f(n,o):u(e)?Oa(e.then((e=>e instanceof Fa?s.toPromise():e))):xa(e)}return qa(n,r)}function v(e){return p(e).toPromise()}function y(o){var r;const s=Pa(n,null!==(r=n.getState().nextTree)&&void 0!==r?r:n.getState().currentTree,o.key);return!e||o.key!==t||a instanceof Fa?s:{...s,isSet:!0,loadable:p(o)}}const b=t=>o=>{if(e){const e=p(h),n="hasValue"===e.state?e.contents:za;a="function"===typeof o?o(n):o,u(a)&&(a=a.then((e=>(S={effect:t,value:e},e))))}else{if(u(o))throw i("Setting atoms to async values is not implemented.");"function"!==typeof o&&(S={effect:t,value:o}),Ka(n,h,"function"===typeof o?e=>{const n=o(e);return S={effect:t,value:n},n}:o)}},T=e=>()=>b(e)(za),R=e=>o=>{var r;const{release:a}=n.subscribeToTransactions((n=>{var r;let{currentTree:a,previousTree:i}=n.getState();i||(j("Transaction subscribers notified without a next tree being present -- this is a bug in Recoil"),i=a);const u=null!==(r=a.atomValues.get(t))&&void 0!==r?r:s;if("hasValue"===u.state){var c,l,d,f;const n=u.contents,r=null!==(c=i.atomValues.get(t))&&void 0!==c?c:s,h="hasValue"===r.state?r.contents:za;(null===(l=S)||void 0===l?void 0:l.effect)!==e||(null===(d=S)||void 0===d?void 0:d.value)!==n?o(n,h,!a.atomValues.has(t)):(null===(f=S)||void 0===f?void 0:f.effect)===e&&(S=null)}}),t);l.set(n,[...null!==(r=l.get(n))&&void 0!==r?r:[],a])};for(const t of d)try{const e=t({node:h,storeID:n.storeID,trigger:r,setSelf:b(t),resetSelf:T(t),onSet:R(t),getPromise:v,getLoadable:p,getInfo_UNSTABLE:y});var m;if(null!=e)l.set(n,[...null!==(m=l.get(n))&&void 0!==m?m:[],e])}catch(g){a=g,c=!0}if(e=!1,!(a instanceof Fa)){var _;const e=a,r=c?Ia(a):u(e)?Oa(function(e,n){const o=n.then((n=>{var r,a;return(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&Ka(e,h,n),n})).catch((n=>{var r,a;throw(null===(a=(null!==(r=e.getState().nextTree)&&void 0!==r?r:e.getState().currentTree).atomValues.get(t))||void 0===a?void 0:a.contents)===o&&Za(e,h,Ia(n)),n}));return o}(n,e)):xa(e);o.atomValues.set(t,r),null===(_=n.getState().nextTree)||void 0===_||_.atomValues.set(t,r)}}return()=>{var e;a--,null===(e=l.get(n))||void 0===e||e.forEach((e=>e())),l.delete(n)}},invalidate:function(){r=void 0},shouldDeleteConfigOnRelease:function(){return void 0!==Wa(t)&&a<=0},dangerouslyAllowMutability:e.dangerouslyAllowMutability,persistence_UNSTABLE:e.persistence_UNSTABLE?{type:e.persistence_UNSTABLE.type,backButton:e.persistence_UNSTABLE.backButton}:void 0,shouldRestoreFromSnapshots:!0,retainedBy:o});return h}function Xa(e){const{default:t,...n}=e;return Ga(t)?function(e){const t=Xa({...e,default:za,persistence_UNSTABLE:void 0===e.persistence_UNSTABLE?void 0:{...e.persistence_UNSTABLE,validator:t=>t instanceof Fa?t:c(e.persistence_UNSTABLE).validator(t,za)},effects:e.effects,effects_UNSTABLE:e.effects_UNSTABLE}),n=Da({key:`${e.key}__withFallback`,get:({get:n})=>{const o=n(t);return o instanceof Fa?e.default:o},set:({set:e},n)=>e(t,n),dangerouslyAllowMutability:e.dangerouslyAllowMutability});return ja(n.key,Wa(e.key)),n}({...n,default:t}):Ya({...n,default:t})}var Qa=Xa;var es=class{constructor(e){var t;l(this,"_map",void 0),l(this,"_keyMapper",void 0),this._map=new Map,this._keyMapper=null!==(t=null===e||void 0===e?void 0:e.mapKey)&&void 0!==t?t:e=>e}size(){return this._map.size}has(e){return this._map.has(this._keyMapper(e))}get(e){return this._map.get(this._keyMapper(e))}set(e,t){this._map.set(this._keyMapper(e),t)}delete(e){this._map.delete(this._keyMapper(e))}clear(){this._map.clear()}},ts=Object.freeze({__proto__:null,MapCache:es});const{LRUCache:ns}=ta,{MapCache:os}=ts,rs={equality:"reference",eviction:"none",maxSize:1/0};var as=function({equality:e=rs.equality,eviction:t=rs.eviction,maxSize:n=rs.maxSize}=rs){return function(e,t,n){switch(e){case"keep-all":return new os({mapKey:n});case"lru":return new ns({mapKey:n,maxSize:c(t)});case"most-recent":return new ns({mapKey:n,maxSize:1})}throw i(`Unrecognized eviction policy ${e}`)}(t,n,function(e){switch(e){case"reference":return e=>e;case"value":return e=>sa(e)}throw i(`Unrecognized equality policy ${e}`)}(e))};const{setConfigDeletionHandler:ss}=Q;var is=function(e){var t,n;const o=as({equality:null!==(t=null===(n=e.cachePolicyForParams_UNSTABLE)||void 0===n?void 0:n.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var n,r;const a=o.get(t);if(null!=a)return a;const{cachePolicyForParams_UNSTABLE:s,...i}=e,u=Qa({...i,key:`${e.key}__${null!==(n=sa(t))&&void 0!==n?n:"void"}`,default:"function"===typeof e.default?e.default(t):e.default,retainedBy_UNSTABLE:"function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE,effects:"function"===typeof e.effects?e.effects(t):"function"===typeof e.effects_UNSTABLE?e.effects_UNSTABLE(t):null!==(r=e.effects)&&void 0!==r?r:e.effects_UNSTABLE});return o.set(t,u),ss(u.key,(()=>{o.delete(t)})),u}};const{setConfigDeletionHandler:us}=Q;let cs=0;var ls=function(e){var t,n;const o=as({equality:null!==(t=null===(n=e.cachePolicyForParams_UNSTABLE)||void 0===n?void 0:n.equality)&&void 0!==t?t:"value",eviction:"keep-all"});return t=>{var n;const r=o.get(t);if(null!=r)return r;const a=`${e.key}__selectorFamily/${null!==(n=sa(t,{allowFunctions:!0}))&&void 0!==n?n:"void"}/${cs++}`,s=n=>e.get(t)(n),i=e.cachePolicy_UNSTABLE,u="function"===typeof e.retainedBy_UNSTABLE?e.retainedBy_UNSTABLE(t):e.retainedBy_UNSTABLE;let c;if(null!=e.set){const n=e.set;c=Da({key:a,get:s,set:(e,o)=>n(t)(e,o),cachePolicy_UNSTABLE:i,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u})}else c=Da({key:a,get:s,cachePolicy_UNSTABLE:i,dangerouslyAllowMutability:e.dangerouslyAllowMutability,retainedBy_UNSTABLE:u});return o.set(t,c),us(c.key,(()=>{o.delete(t)})),c}};const ds=ls({key:"__constant",get:e=>()=>e,cachePolicyForParams_UNSTABLE:{equality:"reference"}});var fs=function(e){return ds(e)};const hs=ls({key:"__error",get:e=>()=>{throw i(e)},cachePolicyForParams_UNSTABLE:{equality:"reference"}});var ps=function(e){return hs(e)};var vs=function(e){return e};const{loadableWithError:ys,loadableWithPromise:ms,loadableWithValue:_s}=V;function gs(e,t){const n=Array(t.length).fill(void 0),o=Array(t.length).fill(void 0);for(const[a,s]of t.entries())try{n[a]=e(s)}catch(r){o[a]=r}return[n,o]}function Ss(e){return null!=e&&!u(e)}function bs(e){return Array.isArray(e)?e:Object.getOwnPropertyNames(e).map((t=>e[t]))}function Ts(e,t){return Array.isArray(e)?t:Object.getOwnPropertyNames(e).reduce(((e,n,o)=>({...e,[n]:t[o]})),{})}function Rs(e,t,n){return Ts(e,n.map(((e,n)=>null==e?_s(t[n]):u(e)?ms(e):ys(e))))}var ws={waitForNone:ls({key:"__waitForNone",get:e=>({get:t})=>{const n=bs(e),[o,r]=gs(t,n);return Rs(e,o,r)},dangerouslyAllowMutability:!0}),waitForAny:ls({key:"__waitForAny",get:e=>({get:t})=>{const n=bs(e),[o,r]=gs(t,n);return r.some((e=>!u(e)))?Rs(e,o,r):new Promise((t=>{for(const[n,a]of r.entries())u(a)&&a.then((a=>{o[n]=a,r[n]=void 0,t(Rs(e,o,r))})).catch((a=>{r[n]=a,t(Rs(e,o,r))}))}))},dangerouslyAllowMutability:!0}),waitForAll:ls({key:"__waitForAll",get:e=>({get:t})=>{const n=bs(e),[o,r]=gs(t,n);if(r.every((e=>null==e)))return Ts(e,o);const a=r.find(Ss);if(null!=a)throw a;return Promise.all(r).then((t=>{return Ts(e,(n=o,t.map(((e,t)=>void 0===e?n[t]:e))));var n}))},dangerouslyAllowMutability:!0}),waitForAllSettled:ls({key:"__waitForAllSettled",get:e=>({get:t})=>{const n=bs(e),[o,r]=gs(t,n);return r.every((e=>!u(e)))?Rs(e,o,r):Promise.all(r.map(((e,t)=>u(e)?e.then((e=>{o[t]=e,r[t]=void 0})).catch((e=>{o[t]=void 0,r[t]=e})):null))).then((()=>Rs(e,o,r)))},dangerouslyAllowMutability:!0}),noWait:ls({key:"__noWait",get:e=>({get:t})=>{try{return _s(t(e))}catch(n){return u(n)?ms(n):ys(n)}},dangerouslyAllowMutability:!0})};const{RecoilLoadable:As}=V,{DefaultValue:Es}=Q,{RecoilRoot:Ns,useRecoilStoreID:ks}=Gn,{isRecoilValue:Vs}=x,{retentionZone:Ls}=be,{freshSnapshot:Ms}=un,{useRecoilState:Cs,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Us,useRecoilStateLoadable:Bs,useRecoilValue:Ds,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:Is,useRecoilValueLoadable:Os,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:xs,useResetRecoilState:Ps,useSetRecoilState:zs}=Io,{useGotoRecoilSnapshot:Fs,useRecoilSnapshot:Ws,useRecoilTransactionObserver:$s}=or,{useRecoilCallback:js}=xr,{noWait:Gs,waitForAll:qs,waitForAllSettled:Hs,waitForAny:Ks,waitForNone:Zs}=ws;var Js={DefaultValue:Es,isRecoilValue:Vs,RecoilLoadable:As,RecoilRoot:Ns,useRecoilStoreID:ks,useRecoilBridgeAcrossReactRoots_UNSTABLE:dr,atom:Qa,selector:Da,atomFamily:is,selectorFamily:ls,constSelector:fs,errorSelector:ps,readOnlySelector:vs,noWait:Gs,waitForNone:Zs,waitForAny:Ks,waitForAll:qs,waitForAllSettled:Hs,useRecoilValue:Ds,useRecoilValueLoadable:Os,useRecoilState:Cs,useRecoilStateLoadable:Bs,useSetRecoilState:zs,useResetRecoilState:Ps,useGetRecoilValueInfo_UNSTABLE:sr,useRecoilRefresher_UNSTABLE:Wr,useRecoilValueLoadable_TRANSITION_SUPPORT_UNSTABLE:xs,useRecoilValue_TRANSITION_SUPPORT_UNSTABLE:Is,useRecoilState_TRANSITION_SUPPORT_UNSTABLE:Us,useRecoilCallback:js,useRecoilTransaction_UNSTABLE:qr,useGotoRecoilSnapshot:Fs,useRecoilSnapshot:Ws,useRecoilTransactionObserver_UNSTABLE:$s,snapshot_UNSTABLE:Ms,useRetain:oo,retentionZone:Ls},Ys=Js.RecoilRoot,Xs=Js.atom,Qs=Js.useRecoilState,ei=Js.useResetRecoilState}}]);